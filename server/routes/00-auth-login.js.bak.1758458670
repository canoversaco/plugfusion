/**
 * Robuste Login-Route mit mehrfachen Fallbacks:
 * - bcrypt (wenn verfügbar), sonst Plaintext-Fallback (Spalte `password`)
 * - Env/Default-Bypass: ADMIN_USER/ADMIN_PASS oder 'admin'/'Admin123!'
 * - On-the-fly Bootstrap: legt 'admin' an, falls DB verfügbar ist und User fehlt
 *
 * Diese Route ist bewusst defensiv und abgestimmt auf unterschiedliche DB-Layer:
 *  - db.get(sql, params)        (sqlite-like)
 *  - db.query(sql, params)      (pg-like)
 *  - db.run(sql, params)        (sqlite run)
 */
module.exports = function registerLoginRoute(app, db){
  const express = require('express')
  const crypto  = require('crypto')
  const router  = express.Router()

  const json = express.json({ limit:'200kb' })
  const ADMIN_USER = process.env.ADMIN_USER || 'admin'
  const ADMIN_PASS = process.env.ADMIN_PASS || 'Admin123!'

  function mkToken(){ return crypto.randomBytes(24).toString('hex') }

  // Best-effort bcrypt laden
  let bcrypt = null
  try { bcrypt = require('bcryptjs') } catch(e){ /* ok, Plaintext-Fallback */ }

  async function dbGetUser(username){
    if (!db) return null
    // sqlite-like
    if (typeof db.get === 'function'){
      try { return await db.get('SELECT * FROM users WHERE username=?', [username]) } catch(e){}
    }
    // pg-like
    if (typeof db.query === 'function'){
      try {
        const r = await db.query('SELECT * FROM users WHERE username=$1 LIMIT 1', [username])
        return r?.rows?.[0] || r?.[0] || null
      } catch(e){}
    }
    // low-level run? (kein read) -> skip
    return null
  }

  async function dbEnsureAdmin(){
    if (!db) return false
    // Existiert schon?
    const u = await dbGetUser(ADMIN_USER)
    if (u) return true

    const fields = ['username','role','created_at']
    const values = [ADMIN_USER,'admin', new Date().toISOString()]

    // Passwortfelder
    let passHash = null
    if (bcrypt){
      try { passHash = await bcrypt.hash(ADMIN_PASS, 10) } catch(e){ passHash = null }
    }

    if (passHash){ fields.push('password_hash'); values.push(passHash) }
    fields.push('password'); values.push(ADMIN_PASS)

    const cols = fields.join(',')
    // Platzhalter für sqlite (?), für pg ($1,$2,..)
    async function trySql(sql, params){
      try{
        if (typeof db.run === 'function') { await db.run(sql, params); return true }
        if (typeof db.query === 'function'){ await db.query(sql, params); return true }
      }catch(e){ /* ignore */ }
      return false
    }

    // CREATE TABLE falls nötig (best effort)
    await trySql(`
      CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        username TEXT UNIQUE NOT NULL,
        password_hash TEXT,
        password TEXT,
        role TEXT DEFAULT 'user',
        created_at TEXT
      )
    `, [])

    // UPSERT (sqlite)
    if (await trySql(
      `INSERT INTO users (${cols}) VALUES (${fields.map(()=>'?').join(',')})
       ON CONFLICT(username) DO UPDATE SET role='admin', password=excluded.password, password_hash=COALESCE(excluded.password_hash, users.password_hash)`,
      values
    )) return true

    // UPSERT (pg)
    const pgParams = values
    const pgPlace  = values.map((_,i)=>'$'+(i+1)).join(',')
    if (await trySql(
      `INSERT INTO users (${cols}) VALUES (${pgPlace})
       ON CONFLICT (username) DO UPDATE SET role='admin', password=EXCLUDED.password, password_hash=COALESCE(EXCLUDED.password_hash, users.password_hash)`,
      pgParams
    )) return true

    // Fallback INSERT (ohne Upsert)
    return await trySql(
      `INSERT INTO users (${cols}) VALUES (${fields.map(()=>'?').join(',')})`, values
    )
  }

  async function verifyPassword(user, plain){
    if (!user) return false
    // 1) bcrypt?
    if (bcrypt && user.password_hash){
      try{ if (await bcrypt.compare(plain, user.password_hash)) return true }catch(e){}
    }
    // 2) Plaintext-Fallback-Spalte
    if (user.password && String(user.password) === String(plain)) return true
    return false
  }

  router.post('/api/login', json, async (req,res)=>{
    try{
      const { username, password } = req.body || {}

      // ❶ Env/Default-Bypass (ohne DB)
      if ((username === ADMIN_USER) && (password === ADMIN_PASS)){
        const token = mkToken()
        return res.json({ ok:true, user:{ username, role:'admin' }, token })
      }

      // ❷ User aus DB laden (falls DB vorhanden)
      let user = await dbGetUser(username)

      // ❸ Falls nicht vorhanden und Admin-Login versucht → Admin automatisch anlegen
      if (!user && username === ADMIN_USER && password === ADMIN_PASS){
        await dbEnsureAdmin()
        user = await dbGetUser(username)
      }

      if (!user){
        return res.status(401).json({ ok:false, error:'invalid_user' })
      }

      const ok = await verifyPassword(user, password)
      if (!ok) return res.status(401).json({ ok:false, error:'wrong_password' })

      // Token generieren (einfacher Bearer für Frontend)
      const token = mkToken()
      const safeUser = { id:user.id, username:user.username, role:user.role || 'user' }
      return res.json({ ok:true, user: safeUser, token })
    }catch(err){
      console.error('LOGIN ERROR', err)
      return res.status(500).json({ ok:false, error:'server_error' })
    }
  })

  // Route registrieren
  app.use(router)
}
