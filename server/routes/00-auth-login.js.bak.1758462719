/**
 * Login-Route (Funktions-Export) + Bootstrap:
 *  - akzeptiert JSON, FORM, Basic-Auth, GET-Query (für Debug)
 *  - prüft DB (sqlite/pg) mit password_hash (bcryptjs) oder password (Plain)
 *  - legt beim Start sicher folgende User an/aktualisiert:
 *      • admin / Admin123   (role=admin)
 *      • plugadmin / plugadmin (role=admin)
 */
module.exports = function(app, db){
  const express = require('express')
  const crypto  = require('crypto')
  let bcrypt = null; try{ bcrypt = require('bcryptjs') }catch{}

  const DEFAULTS = [
    { u: process.env.ADMIN_USER || 'admin',      p: process.env.ADMIN_PASS || 'Admin123', role: 'admin' },
    { u: 'plugadmin', p: 'plugadmin', role: 'admin' }
  ]

  app.use?.(express.json({limit:'200kb'}))
  app.use?.(express.urlencoded({extended:true}))

  const mkToken = ()=> crypto.randomBytes(24).toString('hex')

  function pickCreds(req){
    const b = req.body || {}
    let user = b.username || b.user || b.email || b.login
    let pass = b.password
    const auth = req.headers?.authorization || ''
    if ((!user || !pass) && auth.startsWith('Basic ')){
      try{
        const dec = Buffer.from(auth.split(' ')[1], 'base64').toString('utf8')
        const i = dec.indexOf(':'); if (i>0){ user = user || dec.slice(0,i); pass = pass || dec.slice(i+1) }
      }catch{}
    }
    if ((!user || !pass) && req.method==='GET'){
      user = user || req.query?.username || req.query?.user || req.query?.email || req.query?.login
      pass = pass || req.query?.password
    }
    return { username: String(user||''), password: String(pass||'') }
  }

  async function dbRun(sql, params){
    try{
      if (typeof db?.run === 'function'){ await db.run(sql, params); return true }
      if (typeof db?.query === 'function'){ await db.query(sql, params); return true }
    }catch(e){ /* ignore */ }
    return false
  }
  async function dbGetUser(username){
    try{
      if (typeof db?.get === 'function'){ return await db.get('SELECT * FROM users WHERE username=?',[username]) }
      if (typeof db?.query === 'function'){
        const r = await db.query('SELECT * FROM users WHERE username=$1 LIMIT 1',[username])
        return r?.rows?.[0] || r?.[0] || null
      }
    }catch(e){}
    return null
  }
  async function ensureUser(u, p, role='user'){
    if (!db) return
    await dbRun(`
      CREATE TABLE IF NOT EXISTS users(
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        username TEXT UNIQUE NOT NULL,
        password_hash TEXT,
        password TEXT,
        role TEXT DEFAULT 'user',
        created_at TEXT
      );`, [])
    let hash=null
    if (bcrypt){ try{ hash = await bcrypt.hash(p, 10) }catch{} }
    const fields=['username','role','created_at','password']
    const vals  =[u, role, new Date().toISOString(), p]
    if (hash){ fields.push('password_hash'); vals.push(hash) }

    // sqlite upsert
    const okSqlite = await dbRun(
      `INSERT INTO users (${fields.join(',')}) VALUES (${fields.map(()=>'?').join(',')})
       ON CONFLICT(username) DO UPDATE SET role=excluded.role, password=excluded.password,
       password_hash=COALESCE(excluded.password_hash, users.password_hash)`, vals)
    if (okSqlite) return

    // pg upsert
    const place = vals.map((_,i)=>'$'+(i+1)).join(',')
    await dbRun(
      `INSERT INTO users (${fields.join(',')}) VALUES (${place})
       ON CONFLICT (username) DO UPDATE SET role=EXCLUDED.role, password=EXCLUDED.password,
       password_hash=COALESCE(EXCLUDED.password_hash, users.password_hash)`, vals)
  }
  async function ensureDefaults(){
    for (const d of DEFAULTS){ await ensureUser(d.u, d.p, d.role) }
  }
  ensureDefaults() // beim Laden

  async function checkPass(user, plain){
    if (!user) return false
    if (bcrypt && user.password_hash){
      try{ if (await bcrypt.compare(plain, user.password_hash)) return true }catch{}
    }
    if (user.password && String(user.password)===String(plain)) return true
    // letzter Fallback auf DEFAULTS
    if (DEFAULTS.find(x=>x.u===user.username && x.p===plain)) return true
    return false
  }

  app.get?.('/api/login/ping', (_req,res)=> res.json({ok:true, route:'00-auth-login.js(func)', formats:['json','form','basic','get']}))

  app.post('/api/login', async (req,res)=>{
    try{
      const { username, password } = pickCreds(req)
      if (!username || !password) return res.status(400).json({ error:'missing_credentials' })

      // sofortige Default-Bypässe (auch ohne DB)
      const match = DEFAULTS.find(x=>x.u===username && x.p===password)
      if (match) return res.json({ ok:true, user:{ username, role: match.role }, token: mkToken() })

      // DB-Prüfung
      const user = await dbGetUser(username)
      if (!user) return res.status(401).json({ error:'invalid_user' })
      const ok = await checkPass(user, password)
      if (!ok) return res.status(401).json({ error:'wrong_password' })
      return res.json({ ok:true, user:{ id:user.id, username:user.username, role:user.role||'user' }, token: mkToken() })
    }catch(err){
      console.error('LOGIN ERROR', err)
      res.status(500).json({ error:'server_error' })
    }
  })

  console.log('[login] /api/login aktiv – Defaults:', DEFAULTS.map(x=>x.u).join(', '))
}
